---
title: "Example"
author: "Florian Mayer"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Vignette Title}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r setup, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
library(DT)
library(leaflet)
library(listviewer)
library(magrittr)
library(tibble)
# library(tidyr)
library(ruODK)
```

This vignette demonstrates `ruODK`'s workflow to extract data from ODK Central's
OData service endpoint, and to prepare the data and the media attachments for
further analysis and visualisation.

The demonstrated workflow is roughly equivalent to ODK Central's "Export all data",
which downloads all submissions and all repeating subgroups as CSV spreadsheets,
and all media attachments in a local subfolder "attachments".

# Configure ruODK

Set your ODK Central username (email) and password as R environment variables, 
e.g. in your `~/.Rprofile`.

```{r sys_config, eval=F}
Sys.setenv(ODKC_UN="...@...")
Sys.setenv(ODKC_PW=".......")
```


# Read data from ODK Central
If we know our ODK Central URL, the project ID (a number) and the respective
form ID (an alphanumeric string), we can infer the OData service URL.

Alternatively, the OData service URL is shown in the form's "Submissions" tab >
"Analyze via OData" on ODK Central.

```{r odk_config}
# ODK Central credentials
if (file.exists("~/.Rprofile")) source("~/.Rprofile")

# ODK Central's OData URL
data_url <- "https://sandbox.central.opendatakit.org/v1/projects/14/forms/build_Flora-Quadrat-0-2_1558575936.svc"

data("fq_meta")
data("fq_raw")
data("fq_tae")
```

In our example, the OData service URL is `r data_url`.
Let's first get the metadata to review our data schema.

```{r load_ometadata, eval=F}
fq_meta <- get_metadata(data_url)
```

Each downloadable table is an EntityType under DataServices.Schema.
The main form is called "Submissions". 
Repeating form groups, as in our example "taxon_encounter", are named "Submissions.taxon_encounter". The exact name is found under
DataServices.Schema.EntityType[n].attrs.Name.

```{r view_metadata}
listviewer::jsonedit(fq_meta)
```

So let's download the form submissions and, separately, repeating form groups.

```{r load_odata, eval=F}
fq_raw <- get_submissions(data_url)
fq_tae <- get_submissions(data_url, sub="Submissions.taxon_encounter")
```

The output of the above code is provided as data objects `fq_raw` 
(main submissions of form Flora Quadrat 0.2) and 
`fq_tae` (repeated group "Taxon Encounter" within a Flora Quadrat).

# Rectangle the data
The function `ruODK::get_submissions` returned the original XML response as a 
nested list of lists.
To analyse and visualise the data, this nested list of lists must be transformed 
into a rectangular shape.
The function `ruODK::parse_submissions` recursively unnests list columns using
(tidyr::unnest_wider). Unnamed columns, notably the anonymous lat/lon/alt 
coordinates, are named automatically to become unique.

The repeated subgroup `taxon_encounter` is joined with the main observation
to receive a (repeated) copy of the main observation's values 
(such as observation time and habitat description).

The vectorised function `get_attachment` downloads and links attachments like 
photos and other media to a local, relative path.

The trailing `invisible` is a neutral operation to allow trailing magrittr 
pipelines `%>%` while commenting individual lines of the pipelines in or out.

```{r transform_data}
fq_data <- fq_raw %>% parse_submissions() %>% 
  dplyr::rename(
    uuid=`.__id`,) %>% 
  dplyr::mutate(
    quadrat_photo = get_attachment(data_url, uuid, quadrat_photo),
    morphological_type_photo = get_attachment(data_url, uuid, morphological_type_photo),
    mudmap_photo = get_attachment(data_url, uuid, mudmap_photo)
  ) %>% 
  invisible

fq_data_tae <- fq_tae %>% 
  parse_submissions() %>% 
  dplyr::rename(
    tae_uuid=`.__id`,
    uuid=`.__Submissions.id`) %>%
  dplyr::mutate(
    photo_in_situ = get_attachment(data_url, uuid, photo_in_situ)
  ) %>% 
  dplyr::left_join(fq_data, by="uuid") %>% 
  invisible
```

Note: A manually resized version of the original photos in this example live in
the package source under 
[`docs/articles/attachments`](https://github.com/dbca-wa/ruODK/tree/master/docs/articles/attachments). To minimise package size, they were resized with imagemagick:
`find docs/articles/attachments/ -maxdepth 2 -type f -exec mogrify -resize 300x200 {} \;`.

## DIY rectangling
The unnesting could also be done manually by building up a pipeline, which
stepwise unnests each list column.
This requires knowledge of the data structure, which can either be looked up
from the metadata, or by inspecting the raw data, `fq_raw`.
```{r rectangle_diy}
fq_data_diy <- tibble::tibble(value=fq_raw$value) %>%
  tidyr::unnest_wider(value) %>% 
  # 1. find list columns:
  tidyr::unnest_wider(`__system`) %>% 
  tidyr::unnest_wider(meta) %>% 
  # add more lines here to unnest other form groups
  #
  # 2. rename column names
  dplyr::rename(
    uuid=`__id`
    # add more columns, e.g. 
    # longitude=`...1`, latitude=`...2`, altitude=`...3`
    ) %>%
  # 3. handle media attachments
  # dplyr::mutate(photo_field1 = get_attachment(data_url, uuid, photo_field1)) %>% 
  invisible
```

# Visualise data

## Datatable

```{r vis_data}
DT::datatable(fq_data)
DT::datatable(fq_data_tae)
```

## Map

Constructing label and popup requires knowledge of the dataset structure.

In absence of locally linked attachments (`get_attachment`), we reconstruct
the attachment URL, which (until ODK Central allows anonymous media retrieval) 
fails on the missing authentication.

```{r map_data}
leaflet::leaflet(width = 800, height = 600) %>%
  leaflet::addProviderTiles("OpenStreetMap.Mapnik", group = "Place names") %>%
  leaflet::addProviderTiles("Esri.WorldImagery", group = "Aerial") %>%
  leaflet::clearBounds() %>% 
  leaflet::addAwesomeMarkers(
    data = fq_data,
    lng = ~...12, lat = ~...13,
    icon = leaflet::makeAwesomeIcon(text = "Q", markerColor = "red"),
    label = ~glue::glue('{area_name} {encounter_start_datetime}'),
    popup = ~glue::glue(
      "<h3>{area_name}</h3>",
      "Survey start {encounter_start_datetime}</br>",
      "Reporter {reporter}</br>",
      "Device {device_id}</br>",
      "<h5>Site</h5>",
      '<div><img src="{quadrat_photo}"',
      ' height="150px" alt="Quadrat photo"></img></div>',
      "<h5>Mudmap</h5>",
      '<div><img src="{mudmap_photo}',
      ' height="150px" alt="Mudmap"></img></div>',
      "<h5>Habitat</h5>",
      "Morphological type: {morphological_type}</br>",
      '<div><img src="{morphological_type_photo}"',
      'height="150px" alt="Morphological type"></img></div>',
      "Veg class: {vegclass_placeholder}</br>"
    ),
    clusterOptions = leaflet::markerClusterOptions()
  ) %>%
  leaflet::addLayersControl(
    baseGroups = c("Place names", "Aerial"),
    options = leaflet::layersControlOptions(collapsed = FALSE)
  )
```

```{r map_data_tae}
leaflet::leaflet(width = 800, height = 600) %>%
  leaflet::addProviderTiles("OpenStreetMap.Mapnik", group = "Place names") %>%
  leaflet::addProviderTiles("Esri.WorldImagery", group = "Aerial") %>%
  leaflet::clearBounds() %>% 
  leaflet::addAwesomeMarkers(
    data = fq_data_tae,
    lng = ~...6, lat = ~...7,
    icon = leaflet::makeAwesomeIcon(text = "T", markerColor = "green"),
    label = ~glue::glue('{canonical_name} {encounter_start_datetime}'),
    popup = ~glue::glue(
      "<h3>{area_name}</h3>",
      "Survey start {encounter_start_datetime}</br>",
      "Reporter {reporter}</br>",
      "Device {device_id}</br>",
      "<h5>Taxon</h5>",
      '<div><img src="{photo_in_situ}"',
      ' height="150px" alt="Taxon in situ"></img></div>',
      "Specimen barcode: {voucher_specimen_barcode}</br>",
      "Life form: {life_form}</br>"
    ),
    clusterOptions = leaflet::markerClusterOptions()
  ) %>%
  leaflet::addLayersControl(
    baseGroups = c("Place names", "Aerial"),
    options = leaflet::layersControlOptions(collapsed = FALSE)
  )
```

# Export
The rectangled data can now be exported. e.g. to CSV.
Note that all list columns must be either unnested or dropped before exporting to
CSV.

```{r export, eval=F}
fq_data %>% readr::write_csv("flora_quadrats.csv")
fq_data_tae %>% readr::write_csv("flora_quadrats_taxon_encounters.csv")
```
