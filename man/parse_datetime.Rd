% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/utils.R
\name{parse_datetime}
\alias{parse_datetime}
\title{Parse all columns containing a certain word in its name to localised
datetime.}
\usage{
parse_datetime(df, col_contains = "time", orders = c("YmdHMS",
  "YmdHMSz", "Ymd HMS", "Ymd HMSz"), tz = "Australia/Perth")
}
\arguments{
\item{df}{A dataframe or tibble.}

\item{col_contains}{A character string indicating a date/time column.
This can be a part of the column name or the whole column name.
Default: "time" will match all column names containing "time".}

\item{orders}{(vector of character) Orders of datetime elements for
lubridate.
Default: \code{c("YmdHMS", "YmdHMSz")}.}

\item{tz}{(character) The timezone string for lubridate.
Default: \code{"UTC"}.}
}
\value{
The dataframe with matching columns mutated to lubridate datetimes.
}
\description{
\lifecycle{stable}
}
\details{
This function wraps a \code{`dplyr::mutate_at()`} operation on all
datetime columns containing a tell-tale `col_contains` string like "time"
(default), "datetime" or "date". The operator using this function will have
to know the column names (or commonalities like `"..._time"`).
}
\examples{
\dontrun{
tsi <- "data/build_Turtle-Sighting-0-1_1559790020.csv" \%>\%
  readr::read_csv(na = c("", "NA", "na")) \%>\%
  janitor::clean_names() \%>\%
  link_attachments() \%>\%
  parse_datetime(dt_contains = "Date", tz = "Australia/Perth") \%>\%
  parse_datetime(tz = "Australia/Perth")
}
}
\seealso{
Other utilities: \code{\link{\%>\%}},
  \code{\link{isodt_to_local}}, \code{\link{prepend_uuid}},
  \code{\link{strip_uuid}}, \code{\link{tidyeval}}
}
\concept{utilities}
