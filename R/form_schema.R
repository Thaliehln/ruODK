#' Show the schema of one form.
#'
#' \lifecycle{stable}
#'
#' @details ODK Central has introduced a new API endpoint in version 0.8 which
#' returns a parsed and flattened list of fields. This replaces the nested
#' form schema which is challenging to parse.
#'
#' While users of newest ODK Central versions ( > 0.8) can ignore the legacy
#' support for ODK Central's earlier form schema API, users of ODK Central
#' version < 0.8 can set an environment variable \code{ODKC_VERSION} to their
#' ODKC's version in format \code{<major>.<minor>} e.g. \code{0.7}.
#' This variable caters for future breaking changes.
#'
#' Either way, \code{\link{form_schema}} will always return a tibble with
#' columns \code{name}, \code{type}, \code{path} and \code{ruodk_name}.
#'
#' @param flatten Whether to flatten the resulting list of lists (TRUE) or not
#'   (FALSE, default). Only applies to ODK Central version < 0.8.
#' @param odata Whether to sanitise the field names to match the way they will
#'   be outputted for OData. While the original field names as given in the
#'   XForms definition may be used as-is for CSV output, OData has some
#'   restrictions related to the domain-qualified identifier syntax it uses.
#'   Only applies to ODK Central version < 0.8.
#'   Default: FALSE.
#' @param parse Whether to parse the form schema into a tibble of form field
#'   type and name. This uses \code{\link{form_schema_parse}} internally.
#'   If used together with `flatten=TRUE`, \code{\link{form_schema}} will raise
#'   a warning and return the unparsed, flattened form schema.
#'   Only applies to ODK Central version < 0.8.
#'   Default: TRUE.
#' @template param-pid
#' @template param-fid
#' @template param-url
#' @template param-auth
#' @template param-odkcv
#' @template param-verbose
#' @return A tibble or nested list (v0.7) containing the form definition.
#'   At the lowest nesting level, each form field consists of a list of two
#'   nodes, `name` (the underlying field name) and `type` (the XForms field
#'   type, as in "string", "select1", "geopoint", "binary" and so on).
#'   These fields are nested in lists of tuples `name` (the XForms screen name),
#'   `children` (the fields as described above), `type` ("structure" for non-
#'   repeating screens, "repeat" for repeating screens).
#'   A list with `name` "meta" may precede the structure, if several metadata
#'   fields are captured (e.g. "instanceId", form start datetimes etc.).
#'   In all cases for ODK Central 0.8, and with default parameters
#'   (\code{parse=TRUE}) for ODK Central 0.7, \code{\link{form_schema}} returns
#'   a tibble with the columns:
#'
#'   \itemize{
#'   \item \code{name} The field name as given in the form schema.
#'   \item \code{type} The field type, e.g. "string", "select1", etc.
#'   \item \code{path} The XForms path of the field,
#'   \item \code{ruodk_name} The predicted field name as generated by
#'     \code{\link{odata_submission_get}}, prefixed by the path.
#'   }
# nolint start
#' @seealso \url{https://odkcentral.docs.apiary.io/#reference/forms-and-submissions/'-individual-form/getting-form-schema-fields}
#' @seealso \url{https://odkcentral.docs.apiary.io/#reference/forms-and-submissions/'-individual-form/retrieving-form-schema-json}
# nolint end
#' @family restful-api
#' @export
#' @examples
#' \dontrun{
#' # Set default credentials, see vignette "setup"
#' ruODK::ru_setup(
#'   svc = paste0(
#'     "https://sandbox.central.getodk.org/v1/projects/14/",
#'     "forms/build_Flora-Quadrat-0-2_1558575936.svc"
#'   ),
#'   un = "me@email.com",
#'   pw = "..."
#' )
#'
#' # With explicit pid and fid
#' fs_defaults <- form_schema(pid = 1, fid = "build_xformsId")
#'
#' # With current ODK Central (v0.8)
#' fs <- form_schema()
#'
#' # With defaults, ODK Central v0.7
#' fs_nested <- form_schema(
#'   flatten = FALSE,
#'   odata = FALSE,
#'   parse = FALSE,
#'   odkc_version = 0.7
#' )
#' listviewer::jsonedit(fs_nested)
#'
#' fs_flattened <- form_schema(
#'   flatten = TRUE,
#'   odata = FALSE,
#'   parse = FALSE,
#'   odkc_version = 0.7
#' )
#' listviewer::jsonedit(fs_flattened)
#'
#' # form_schema returns a nested list. There's nothing to change about that.
#' class(fs_nested)
#' # > "list"
#'
#' class(fs_flattened)
#' # > "list"
#'
#' # This assumes knowledge of that exact form being tested.
#' # First node: type "structure" (a field group) named "meta".
#' fs_nested[[1]]$type
#' # > "structure"
#'
#' fs_nested[[1]]$name
#' # > "meta"
#'
#' # The first node contains children, which means it's an XForms field group.
#' names(fs_nested[[1]])
#' # > "name" "children" "type"
#'
#' # Next node: a "meta" field of type "string" capturing the  "instanceId".
#' # First child node of "meta": type "string", name "instanceId".
#' fs_nested[[1]]$children[[1]]$type
#' # > "string"
#' fs_nested[[1]]$children[[1]]$name
#' # > "instanceID"
#'
#' # In the flattened version, the field's and it's ancestors' names are the
#' # components of "path".
#' fs_flattened[[1]]$path
#' # > "meta". "instanceId"
#'
#' fs_flattened[[1]]$type
#' # > "string"
#'
#' # Last node: a "meta" field capturing the datetime of form completion
#' fs_flattened[[length(fs_flattened)]]$type
#' # > "dateTime"
#' fs_nested[[length(fs_nested)]]$type
#' # > "dateTime"
#'
#' # Parsed into a tibble of form field type/name:
#' # Useful to inform further parsing of submission data (attachments, dates)
#' fs <- form_schema(parse = TRUE, odkc_version = 0.7)
#' fs <- form_schema(odkc_version = 0.8)
#'
#' # Attachments: used by handle_ru_attachments
#' fs %>% dplyr::filter(type == "binary")
#'
#' # dateTime: used by handle_ru_datetimes
#' fs %>% dplyr::filter(type == "dateTime")
#'
#' # Point location: used by handle_ru_geopoints
#' fs %>% dplyr::filter(type == "geopoint")
#' }
form_schema <- function(flatten = FALSE,
                        odata = FALSE,
                        parse = TRUE,
                        pid = get_default_pid(),
                        fid = get_default_fid(),
                        url = get_default_url(),
                        un = get_default_un(),
                        pw = get_default_pw(),
                        odkc_version = get_default_odkc_version(),
                        verbose = get_ru_verbose()) {
  yell_if_missing(url, un, pw, pid = pid, fid = fid)

  if (odkc_version < 0.8) {
    url_v7 <- glue::glue("{url}/v1/projects/{pid}/forms/{fid}.schema.json")
    if (verbose == TRUE) {
      ru_msg_info(glue::glue("Reading v0.7 form schema from {url_v7}"))
    }

    fs <- httr::RETRY(
      "GET",
      url_v7,
      httr::add_headers("Accept" = "application/json"),
      httr::authenticate(un, pw),
      query = list(flatten = flatten, odata = odata)
    ) %>%
      yell_if_error(., url, un, pw) %>%
      httr::content(.)

    if (parse == TRUE) {
      if (flatten == TRUE) {
        ru_msg_warn(
          "Cannot parse flattened form schema, returning unparsed and flattened.
        Use flatten=FALSE with parse=TRUE for a parsed form_schema."
        )
        return(fs)
      }
      fsp <- form_schema_parse(fs, verbose = verbose) %>%
        dplyr::mutate(ruodk_name = predict_ruodk_name(name, path))
      return(fsp)
    }
    return(fs)
  } else {
    url_v8 <- glue::glue("{url}/v1/projects/{pid}/forms/{fid}/fields")
    if (verbose == TRUE) {
      ru_msg_info(glue::glue("Reading v0.8 form fields from {url_v8}"))
    }

    httr::RETRY(
      "GET",
      url_v8,
      httr::add_headers("Accept" = "application/json"),
      httr::authenticate(un, pw),
      query = list(flatten = flatten, odata = odata)
    ) %>%
      yell_if_error(., url, un, pw) %>%
      httr::content(.) %>%
      rlist::list.select(name, type, path) %>%
      rlist::list.stack(.) %>%
      tibble::as_tibble() %>%
      dplyr::mutate(
        ruodk_name = path %>%
          stringr::str_remove("/") %>%
          stringr::str_replace_all("/", "_")
      )
  }
}

# Tests
# usethis::edit_file("tests/testthat/test-form_schema.R")
