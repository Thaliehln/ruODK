# library(xml2)
#' Show the extended schema of one form.
#'
#' \lifecycle{experimental}
#'
#' @details ODK Central has introduced a new API endpoint in version 0.8 which
#' returns a parsed and flattened list of fields. This replaces the nested
#' form schema which is challenging to parse. This list is returned
#' by \code{\link{form_schema}}.
#'
#' However this still misses important elements, in particular \code{labels} and
#' \code{choice_lists}.
#'
#' \code{\link{form_schema_ext}} returns the same object as \code{\link{form_schema}}
#' adding \code{labels} and \code{choice lists} in all languages available. This is
#' done by using the return object from \code{\link{form_xml}}
#'
#' It has the exact function signature as \code{\link{form_schema}}.
#' In that sense, any call to \code{\link{form_schema}} can be replaced
#' by \code{\link{form_schema_ext}}
#' 
#' This function, however, has been prepared with ODK Center version 0.8 or higher.
#' If you use with earlier version, a warning will be given.
#'
#'
#' @param flatten Whether to flatten the resulting list of lists (TRUE) or not
#'   (FALSE, default). Only applies to ODK Central version < 0.8.
#' @param odata Whether to sanitise the field names to match the way they will
#'   be outputted for OData. While the original field names as given in the
#'   XForms definition may be used as-is for CSV output, OData has some
#'   restrictions related to the domain-qualified identifier syntax it uses.
#'   Only applies to ODK Central version < 0.8.
#'   Default: FALSE.
#' @param parse Whether to parse the form schema into a tibble of form field
#'   type and name. This uses \code{\link{form_schema_parse}} internally.
#'   If used together with `flatten=TRUE`, \code{\link{form_schema}} will raise
#'   a warning and return the unparsed, flattened form schema.
#'   Only applies to ODK Central version < 0.8.
#'   Default: TRUE.
#' @template param-pid
#' @template param-fid
#' @template param-url
#' @template param-auth
#' @template param-retries
#' @template param-odkcv
#' @template param-verbose
#' @return A tibble containing the form definition.
#'   For ODK Central 0.8, and with default parameters
#'   (\code{parse=TRUE}) for ODK Central 0.7, \code{\link{form_schema}} returns
#'   a tibble with the columns:
#'
#'   \itemize{
#'   \item \code{name} The field name as given in the form schema.
#'   \item \code{type} The field type, e.g. "string", "select1", etc.
#'   \item \code{path} The XForms path of the field,
#'   \item \code{ruodk_name} The predicted field name as generated by
#'     \code{\link{odata_submission_get}}, prefixed by the path, additionally
#'     cleaned with \code{\link[janitor]{make_clean_names}} to match the
#'     cleaned column names from \code{\link{odata_submission_rectangle}}.
#'   \item \code{label} The field label as given in the form schema. If specific languages are available, 
#'     this column will return the \code{default} language or it will be empty if this is not specified.
#'   \item \code{label\emph{_lang}} The field label in languange \emph{_lang} as given in the form schema.
#'   \item \code{choices} A list of lists containing at least \code{values} and, if available, 
#'     \code{labels} of the choices as given in the form schema. If specific languages are available, 
#'     this column will return the \code{default} language or it will be empty if this is not specified.
#'   \item \code{choices\emph{_lang}} A list of lists containing at least \code{values} and, if available, 
#'     \code{labels} of the choices in language \emph{_lang} as given in the form schema
#'   
#'   }
# nolint start
#' @seealso \url{https://odkcentral.docs.apiary.io/#reference/forms-and-submissions/'-individual-form/getting-form-schema-fields}
#' @seealso \url{https://odkcentral.docs.apiary.io/#reference/forms-and-submissions/'-individual-form/retrieving-form-
#' @seealso \url{https://odkcentral.docs.apiary.io/#reference/forms-and-submissions/'-individual-form/retrieving-form-xml}
# nolint end
#' @family restful-api
#' @export
#' @examples
#' \dontrun{
#' # Set default credentials, see vignette "setup"
#' ruODK::ru_setup(
#'   svc = paste0(
#'     "https://sandbox.central.getodk.org/v1/projects/14/",
#'     "forms/build_Flora-Quadrat-0-2_1558575936.svc"
#'   ),
#'   un = "me@email.com",
#'   pw = "..."
#' )
#'
#' # With explicit pid and fid
#' fs_defaults <- form_schema(pid = 1, fid = "build_xformsId")
#'
#' # With current ODK Central (v0.8)
#' fs <- form_schema()
#'
#' # With defaults, ODK Central v0.7
#' fs_nested <- form_schema(
#'   flatten = FALSE,
#'   odata = FALSE,
#'   parse = FALSE,
#'   odkc_version = 0.7
#' )
#' listviewer::jsonedit(fs_nested)
#'
#' fs_flattened <- form_schema(
#'   flatten = TRUE,
#'   odata = FALSE,
#'   parse = FALSE,
#'   odkc_version = 0.7
#' )
#' listviewer::jsonedit(fs_flattened)
#'
#' # form_schema returns a nested list. There's nothing to change about that.
#' class(fs_nested)
#' # > "list"
#'
#' class(fs_flattened)
#' # > "list"
#'
#' # This assumes knowledge of that exact form being tested.
#' # First node: type "structure" (a field group) named "meta".
#' fs_nested[[1]]$type
#' # > "structure"
#'
#' fs_nested[[1]]$name
#' # > "meta"
#'
#' # The first node contains children, which means it's an XForms field group.
#' names(fs_nested[[1]])
#' # > "name" "children" "type"
#'
#' # Next node: a "meta" field of type "string" capturing the  "instanceId".
#' # First child node of "meta": type "string", name "instanceId".
#' fs_nested[[1]]$children[[1]]$type
#' # > "string"
#' fs_nested[[1]]$children[[1]]$name
#' # > "instanceID"
#'
#' # In the flattened version, the field's and it's ancestors' names are the
#' # components of "path".
#' fs_flattened[[1]]$path
#' # > "meta". "instanceId"
#'
#' fs_flattened[[1]]$type
#' # > "string"
#'
#' # Last node: a "meta" field capturing the datetime of form completion
#' fs_flattened[[length(fs_flattened)]]$type
#' # > "dateTime"
#' fs_nested[[length(fs_nested)]]$type
#' # > "dateTime"
#'
#' # Parsed into a tibble of form field type/name:
#' # Useful to inform further parsing of submission data (attachments, dates)
#' fs <- form_schema(parse = TRUE, odkc_version = 0.7)
#' fs <- form_schema(odkc_version = 0.8)
#'
#' # Attachments: used by handle_ru_attachments
#' fs %>% dplyr::filter(type == "binary")
#'
#' # dateTime: used by handle_ru_datetimes
#' fs %>% dplyr::filter(type == "dateTime")
#'
#' # Point location: used by handle_ru_geopoints
#' fs %>% dplyr::filter(type == "geopoint")
#' }
form_schema_ext <- function(flatten = FALSE, odata = FALSE, parse = TRUE, pid = get_default_pid(),
                            fid = get_default_fid(), url = get_default_url(), un = get_default_un(),
                            pw = get_default_pw(), odkc_version = get_default_odkc_version(),
                            retries = get_retries(), verbose = get_ru_verbose()) {
  
  # version warning:
  if (odkc_version < 0.8){
    warning("Form Schema Extended works better with ODK Central 0.8 and above",
            immediate. = TRUE)
  }

  # gets basic schema
  frm_schema <- form_schema(
    flatten, odata, parse, pid,
    fid, url, un,
    pw, odkc_version,
    retries, verbose
  )

  # gets xml representation
  frm_xml <- xml2::as_xml_document(form_xml(
    parse, pid, fid,
    url, un, pw,
    retries
  ))


  ### parse translations:
  all_translations <- xml2::xml_find_all(frm_xml, "//text")

  # initialize dataframe
  extension <- data.frame(
    path = character(0), label = character(0),
    stringsAsFactors = FALSE
  )


  ### PART 1: parse labels:
  raw_labels <- xml2::xml_find_all(frm_xml, "//label")

  # iterate thorugh labels
  for (i in 1:length(raw_labels)) {


    ## reads label
    this_rawlabel <- raw_labels[i]

    ## path
    # gets ref from parent, without leading "/data"
    this_path <- sub(
      "/data", "",
      xml2::xml_attr(xml2::xml_parent(this_rawlabel), "ref")
    )

    # ensure this is a valid path
    if (!is.na(this_path)) {


      # adds new empty row:
      extension[nrow(extension) + 1, ] <- rep(NA, ncol(extension))

      # adds path
      extension[nrow(extension), "path"] <- this_path

      # first checks if label is mapped with a translation function
      has_translation <- xml2::xml_has_attr(this_rawlabel, "ref")

      if (has_translation) {
        # finds all translations related to this path:
        id <- sub("')", "", sub("jr:itext\\('", "", xml2::xml_attr(this_rawlabel, "ref")))
        translations <- all_translations[xml2::xml_attr(all_translations, "id") == id]

        # iterate through translations
        for (j in 1:length(translations)) {
          this_translation <- translations[j]

          # first check this is a regular text labels. Questions in ODK can have video, image and audio "labels",
          # which will be skipped. This is identified by the presence of the 'form' attribute:
          is_regular_label <- !xml2::xml_has_attr(xml2::xml_find_first(this_translation, "./value"), "form")

          if (is_regular_label) {
            # reads the parent node to identify language:
            translation_parent <- xml2::xml_parent(this_translation)
            this_lang <- gsub(" ", "_", tolower(xml2::xml_attr(translation_parent, "lang")))

            # decide if 'default' language or specific language
            if (this_lang == "default") {
              # if 'default' language, save under column 'label':
              extension[nrow(extension), "label"] <- xml2::xml_text(xml2::xml_find_first(this_translation, "./value"))
            }
            else {
              # check if language already exists in the datafram
              if (!(paste0("label_", this_lang) %in% colnames(extension))) {

                # if not, create new column
                extension <- cbind(extension, data.frame(new_lang = rep(NA, nrow(extension))))
                colnames(extension)[ncol(extension)] <- paste0("label_", this_lang)
              }

              # adds the first value content of the translation
              extension[nrow(extension), paste0("label_", this_lang)] <- xml2::xml_text(xml2::xml_find_first(this_translation, "./value"))
            }
          }
        }
      }
      else {
        # extract content
        extension[nrow(extension), "label"] <- xml2::xml_text(this_rawlabel)
      }

      ### PART 1.1: parse choice labels
      ## checks existence of  choice list:
      choice_items <- xml2::xml_find_all(xml2::xml_parent(this_rawlabel), "./item")
      if (length(choice_items) > 0) {

        # check if 'choices' column already exist
        if (!("choices" %in% colnames(extension))) {

          # if not, create new column
          extension <- cbind(extension, data.frame(choices = rep(NA, nrow(extension))))
        }

        # initialize lists
        choice_values <- list()
        choice_labels <- list()

        # iterate through choice list:
        for (jj in 1:length(choice_items)) {

          ## reads choice item
          this_choiceitem <- choice_items[jj]

          # value
          this_choicevalue <- xml2::xml_text(xml2::xml_find_first(this_choiceitem, "./value"))
          choice_values[jj] <- this_choicevalue

          # raw label
          this_rawchoicelabel <- xml2::xml_find_first(this_choiceitem, "./label")

          # first checks if choice label is mapped with a translation function
          has_translation_choice <- xml2::xml_has_attr(this_rawchoicelabel, "ref")

          if (has_translation_choice) {
            id_choice <- sub("')", "", sub("jr:itext\\('", "", xml2::xml_attr(this_rawchoicelabel, "ref")))
            choice_translations <- all_translations[xml2::xml_attr(all_translations, "id") == id_choice]


            # iterate through choice translations
            for (kk in 1:length(choice_translations)) {

              # read translation
              this_choicetranslation <- choice_translations[kk]

              # first check this is a regular text labels. Questions in ODK can have video, image and audio "labels",
              # which will be skipped. This is identified by the presence of the 'form' attribute:
              is_regular_choicelabel <- !xml2::xml_has_attr(xml2::xml_find_first(this_choicetranslation, "./value"), "form")

              if (is_regular_choicelabel) {
                # reads the parent node to identify language:
                choice_translation_parent <- xml2::xml_parent(this_choicetranslation)
                this_choicelang <- gsub(" ", "_", tolower(xml2::xml_attr(choice_translation_parent, "lang")))

                # decide if 'default' language or specific language
                if (this_choicelang == "default") {
                  # if 'default' language, save under 'choice':
                  choice_labels[["base"]][jj] <- xml2::xml_text(xml2::xml_find_first(this_choicetranslation, "./value"))
                }
                else {
                  # check if language already exists in the dataframe
                  if (!(paste0("choices_", this_choicelang) %in% colnames(extension))) {

                    # if not, create new column
                    extension <- cbind(extension, data.frame(new_choicelang = rep(NA, nrow(extension))))
                    colnames(extension)[ncol(extension)] <- paste0("choices_", this_choicelang)
                  }

                  # adds the first value content of the translation
                  choice_labels[[paste0("choices_", this_choicelang)]][jj] <- xml2::xml_text(xml2::xml_find_first(this_choicetranslation, "./value"))
                }
              }
            }
          }
          else {
            choice_labels[["base"]][jj] <- xml2::xml_text(this_rawchoicelabel)
          }
        }

        # add to the extended table:
        for (this_choicelang in names(choice_labels)) {
          these_choicelabels <- choice_labels[[this_choicelang]]

          if (this_choicelang == "base") {
            this_choicelang_colname <- "choices"
          }
          else {
            this_choicelang_colname <- this_choicelang
          }

          extension[nrow(extension), this_choicelang_colname] <- list(list(list(
            values = unlist(choice_values),
            labels = unlist(these_choicelabels)
          )))
        }
      }
    }
  }


  # join:
  fs_ext <- frm_schema %>% dplyr::left_join(extension, by = "path")

  ##
  return(fs_ext)
}

# usethis::edit_file("tests/testthat/test-form_schema_ext.R") # nolint
